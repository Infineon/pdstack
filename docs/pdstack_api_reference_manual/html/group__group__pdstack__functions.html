<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PDStack Middleware Library 1.20: Functions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen_style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><a href="http://www.cypress.com/"><img alt="Logo" src="logo.png"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PDStack Middleware Library 1.20</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__group__pdstack__functions.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Functions</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">General Description</h2>
<p>This section describes the PDStack Function Prototypes. </p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga201503833db097afe5c9e0d18e8e03ea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__pdstack__enums.html#ga2115782809414a20b28e6f5df83b7a7f">cy_en_pdstack_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__pdstack__functions.html#ga201503833db097afe5c9e0d18e8e03ea">Cy_PdStack_Dpm_Init</a> (<a class="el" href="structcy__stc__pdstack__context__t.html">cy_stc_pdstack_context_t</a> *ptrPdStackContext, cy_stc_usbpd_context_t *ptrUsbPdContext, const <a class="el" href="structcy__stc__pdstack__port__cfg__t.html">cy_stc_pdstack_port_cfg_t</a> *ptrPortCfg, <a class="el" href="structcy__stc__pdstack__app__cbk__t.html">cy_stc_pdstack_app_cbk_t</a> *ptrAppCbk, const <a class="el" href="structcy__stc__pdstack__dpm__params__t.html">cy_stc_pdstack_dpm_params_t</a> *ptrDpmParams, <a class="el" href="structcy__stc__sw__timer__t.html">cy_stc_sw_timer_t</a> *ptrTimerContext)</td></tr>
<tr class="memdesc:ga201503833db097afe5c9e0d18e8e03ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function initializes the device policy manager with callback pointers and loads the port configuration information from the port config table.  <a href="#ga201503833db097afe5c9e0d18e8e03ea">More...</a><br /></td></tr>
<tr class="separator:ga201503833db097afe5c9e0d18e8e03ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae9893510cb213c6b799bb490b76d513"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__pdstack__enums.html#ga2115782809414a20b28e6f5df83b7a7f">cy_en_pdstack_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__pdstack__functions.html#gaae9893510cb213c6b799bb490b76d513">Cy_PdStack_Dpm_Start</a> (<a class="el" href="structcy__stc__pdstack__context__t.html">cy_stc_pdstack_context_t</a> *ptrPdStackContext)</td></tr>
<tr class="memdesc:gaae9893510cb213c6b799bb490b76d513"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function makes the specified USB Type-C port operational.  <a href="#gaae9893510cb213c6b799bb490b76d513">More...</a><br /></td></tr>
<tr class="separator:gaae9893510cb213c6b799bb490b76d513"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga67ca2bbf457f4a9777dc121eb53f445b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__pdstack__enums.html#ga2115782809414a20b28e6f5df83b7a7f">cy_en_pdstack_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__pdstack__functions.html#ga67ca2bbf457f4a9777dc121eb53f445b">Cy_PdStack_Dpm_Stop</a> (<a class="el" href="structcy__stc__pdstack__context__t.html">cy_stc_pdstack_context_t</a> *ptrPdStackContext)</td></tr>
<tr class="memdesc:ga67ca2bbf457f4a9777dc121eb53f445b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function stops the port operation.  <a href="#ga67ca2bbf457f4a9777dc121eb53f445b">More...</a><br /></td></tr>
<tr class="separator:ga67ca2bbf457f4a9777dc121eb53f445b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b02e2958684a052e39ec007b2f646e1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__pdstack__enums.html#ga2115782809414a20b28e6f5df83b7a7f">cy_en_pdstack_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__pdstack__functions.html#ga5b02e2958684a052e39ec007b2f646e1">Cy_PdStack_Dpm_Disable</a> (<a class="el" href="structcy__stc__pdstack__context__t.html">cy_stc_pdstack_context_t</a> *ptrPdStackContext)</td></tr>
<tr class="memdesc:ga5b02e2958684a052e39ec007b2f646e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function disables the PD port operation and limits it to receiving hard reset signalling.  <a href="#ga5b02e2958684a052e39ec007b2f646e1">More...</a><br /></td></tr>
<tr class="separator:ga5b02e2958684a052e39ec007b2f646e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d640baff9e0b6140d80b4ed2c41aa1c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__pdstack__enums.html#ga2115782809414a20b28e6f5df83b7a7f">cy_en_pdstack_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__pdstack__functions.html#ga8d640baff9e0b6140d80b4ed2c41aa1c">Cy_PdStack_Dpm_PrepareDeepSleep</a> (<a class="el" href="structcy__stc__pdstack__context__t.html">cy_stc_pdstack_context_t</a> *ptrPdStackContext, bool *ptrDeepSleep)</td></tr>
<tr class="memdesc:ga8d640baff9e0b6140d80b4ed2c41aa1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function configures the PD policy manager and Type-C manager state machines to allow the PMG1 device to be placed in deep sleep.  <a href="#ga8d640baff9e0b6140d80b4ed2c41aa1c">More...</a><br /></td></tr>
<tr class="separator:ga8d640baff9e0b6140d80b4ed2c41aa1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5de1c7b55d33cd596b43dcf222ffd8c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__pdstack__enums.html#ga2115782809414a20b28e6f5df83b7a7f">cy_en_pdstack_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__pdstack__functions.html#gac5de1c7b55d33cd596b43dcf222ffd8c">Cy_PdStack_Dpm_Resume</a> (<a class="el" href="structcy__stc__pdstack__context__t.html">cy_stc_pdstack_context_t</a> *ptrPdStackContext, bool *ptrResume)</td></tr>
<tr class="memdesc:gac5de1c7b55d33cd596b43dcf222ffd8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function resumes the Type-C manager and PD policy engine state machines after the PMG1 device has woken up from deep sleep.  <a href="#gac5de1c7b55d33cd596b43dcf222ffd8c">More...</a><br /></td></tr>
<tr class="separator:gac5de1c7b55d33cd596b43dcf222ffd8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga242623fe6b5efbf33c83ab3c3323e7be"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__pdstack__enums.html#ga2115782809414a20b28e6f5df83b7a7f">cy_en_pdstack_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__pdstack__functions.html#ga242623fe6b5efbf33c83ab3c3323e7be">Cy_PdStack_Dpm_IsSleepAllowed</a> (<a class="el" href="structcy__stc__pdstack__context__t.html">cy_stc_pdstack_context_t</a> *ptrPdStackContext, bool *ptrSleepAllowed)</td></tr>
<tr class="memdesc:ga242623fe6b5efbf33c83ab3c3323e7be"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function checks if the PD policy engine and Type-C manager state machines corresponding to the specified Type-C port are idle.  <a href="#ga242623fe6b5efbf33c83ab3c3323e7be">More...</a><br /></td></tr>
<tr class="separator:ga242623fe6b5efbf33c83ab3c3323e7be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6351a34299af47084a316107294a50a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__pdstack__enums.html#ga2115782809414a20b28e6f5df83b7a7f">cy_en_pdstack_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__pdstack__functions.html#ga6351a34299af47084a316107294a50a1">Cy_PdStack_Dpm_Rtos_Init</a> (<a class="el" href="structcy__stc__pdstack__context__t.html">cy_stc_pdstack_context_t</a> *ptrPdStackContext, <a class="el" href="structcy__stc__pdstack__rtos__context__t.html">cy_stc_pdstack_rtos_context_t</a> *ptrRtosContext)</td></tr>
<tr class="memdesc:ga6351a34299af47084a316107294a50a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function initializes the device policy manager with RTOS context details.  <a href="#ga6351a34299af47084a316107294a50a1">More...</a><br /></td></tr>
<tr class="separator:ga6351a34299af47084a316107294a50a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa7461e8739b31c7c212e2af74f230c80"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__pdstack__enums.html#ga2115782809414a20b28e6f5df83b7a7f">cy_en_pdstack_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__pdstack__functions.html#gaa7461e8739b31c7c212e2af74f230c80">Cy_PdStack_Dpm_Task</a> (<a class="el" href="structcy__stc__pdstack__context__t.html">cy_stc_pdstack_context_t</a> *ptrPdStackContext)</td></tr>
<tr class="memdesc:gaa7461e8739b31c7c212e2af74f230c80"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function runs the Type-C manager and PD policy manager tasks for the specified port.  <a href="#gaa7461e8739b31c7c212e2af74f230c80">More...</a><br /></td></tr>
<tr class="separator:gaa7461e8739b31c7c212e2af74f230c80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5899a0d50296f6656ed39a13fedf68b3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__pdstack__enums.html#ga2115782809414a20b28e6f5df83b7a7f">cy_en_pdstack_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__pdstack__functions.html#ga5899a0d50296f6656ed39a13fedf68b3">Cy_PdStack_Dpm_SendPdCommand</a> (<a class="el" href="structcy__stc__pdstack__context__t.html">cy_stc_pdstack_context_t</a> *ptrPdStackContext, <a class="el" href="group__group__pdstack__enums.html#gaab347ed9d4ea3174377c728e9304fa27">cy_en_pdstack_dpm_pd_cmd_t</a> cmd, <a class="el" href="structcy__stc__pdstack__dpm__pd__cmd__buf__t.html">cy_stc_pdstack_dpm_pd_cmd_buf_t</a> *ptrCmdBuf, bool isResp, <a class="el" href="group__group__pdstack__data__structures.html#ga8032135e3e0bcc286f569781a51f50a2">cy_pdstack_dpm_pd_cmd_cbk_t</a> cmdCbk)</td></tr>
<tr class="memdesc:ga5899a0d50296f6656ed39a13fedf68b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function provides an interface for the application module to send PD commands.  <a href="#ga5899a0d50296f6656ed39a13fedf68b3">More...</a><br /></td></tr>
<tr class="separator:ga5899a0d50296f6656ed39a13fedf68b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga55149c2f22c57f73b1de2dd7a791ada5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__pdstack__enums.html#ga2115782809414a20b28e6f5df83b7a7f">cy_en_pdstack_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__pdstack__functions.html#ga55149c2f22c57f73b1de2dd7a791ada5">Cy_PdStack_Dpm_SendTypecCommand</a> (<a class="el" href="structcy__stc__pdstack__context__t.html">cy_stc_pdstack_context_t</a> *ptrPdStackContext, <a class="el" href="group__group__pdstack__enums.html#gaf1be4da8f6e2a81a74ba4248ae63fc62">cy_en_pdstack_dpm_typec_cmd_t</a> cmd, <a class="el" href="group__group__pdstack__data__structures.html#ga3f4fb1cb7b6b853659e8d2ea7db20884">cy_pdstack_dpm_typec_cmd_cbk_t</a> cmdCbk)</td></tr>
<tr class="memdesc:ga55149c2f22c57f73b1de2dd7a791ada5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function provides an interface for the application module to send commands to the Type-C connection manager.  <a href="#ga55149c2f22c57f73b1de2dd7a791ada5">More...</a><br /></td></tr>
<tr class="separator:ga55149c2f22c57f73b1de2dd7a791ada5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83cc6a82b07642504b719a809811018e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__pdstack__enums.html#ga2115782809414a20b28e6f5df83b7a7f">cy_en_pdstack_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__pdstack__functions.html#ga83cc6a82b07642504b719a809811018e">Cy_PdStack_Dpm_ProtReset</a> (<a class="el" href="structcy__stc__pdstack__context__t.html">cy_stc_pdstack_context_t</a> *ptrPdStackContext, cy_en_pd_sop_t sop)</td></tr>
<tr class="memdesc:ga83cc6a82b07642504b719a809811018e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function resets PD protocol layer (transmit and receive) message ID counters for the specified PD packet type.  <a href="#ga83cc6a82b07642504b719a809811018e">More...</a><br /></td></tr>
<tr class="separator:ga83cc6a82b07642504b719a809811018e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6e5f920dff34b6786198a006302d2fb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__pdstack__enums.html#ga2115782809414a20b28e6f5df83b7a7f">cy_en_pdstack_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__pdstack__functions.html#gad6e5f920dff34b6786198a006302d2fb">Cy_PdStack_Dpm_ProtResetRx</a> (<a class="el" href="structcy__stc__pdstack__context__t.html">cy_stc_pdstack_context_t</a> *ptrPdStackContext, cy_en_pd_sop_t sop)</td></tr>
<tr class="memdesc:gad6e5f920dff34b6786198a006302d2fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function resets the PD receive message counter for the specified packet type.  <a href="#gad6e5f920dff34b6786198a006302d2fb">More...</a><br /></td></tr>
<tr class="separator:gad6e5f920dff34b6786198a006302d2fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b1ec4633e71be2e67aa9b34a52283b9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__pdstack__enums.html#ga2115782809414a20b28e6f5df83b7a7f">cy_en_pdstack_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__pdstack__functions.html#ga0b1ec4633e71be2e67aa9b34a52283b9">Cy_PdStack_Dpm_PeStop</a> (<a class="el" href="structcy__stc__pdstack__context__t.html">cy_stc_pdstack_context_t</a> *ptrPdStackContext)</td></tr>
<tr class="memdesc:ga0b1ec4633e71be2e67aa9b34a52283b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function stops the policy engine.  <a href="#ga0b1ec4633e71be2e67aa9b34a52283b9">More...</a><br /></td></tr>
<tr class="separator:ga0b1ec4633e71be2e67aa9b34a52283b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga649792612bdbf447fd5a80098014edf3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__pdstack__enums.html#ga2115782809414a20b28e6f5df83b7a7f">cy_en_pdstack_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__pdstack__functions.html#ga649792612bdbf447fd5a80098014edf3">Cy_PdStack_Dpm_Pd3SrcRpFlowControl</a> (<a class="el" href="structcy__stc__pdstack__context__t.html">cy_stc_pdstack_context_t</a> *ptrPdStackContext, bool blockSinkAms)</td></tr>
<tr class="memdesc:ga649792612bdbf447fd5a80098014edf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used to specify whether we should keep the Rp termination at SinkTxNG or SinkTxOK while acting as a PD 3.0 source.  <a href="#ga649792612bdbf447fd5a80098014edf3">More...</a><br /></td></tr>
<tr class="separator:ga649792612bdbf447fd5a80098014edf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga74d202e6caa7ed979d2429038462d53c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__pdstack__enums.html#ga2115782809414a20b28e6f5df83b7a7f">cy_en_pdstack_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__pdstack__functions.html#ga74d202e6caa7ed979d2429038462d53c">Cy_PdStack_Dpm_IsIdle</a> (<a class="el" href="structcy__stc__pdstack__context__t.html">cy_stc_pdstack_context_t</a> *ptrPdStackContext, bool *ptrIsIdle)</td></tr>
<tr class="memdesc:ga74d202e6caa7ed979d2429038462d53c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to check whether the Type-C/PD stack is idle.  <a href="#ga74d202e6caa7ed979d2429038462d53c">More...</a><br /></td></tr>
<tr class="separator:ga74d202e6caa7ed979d2429038462d53c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1534293c5924a4148d9669ade2c83fc5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__pdstack__functions.html#ga1534293c5924a4148d9669ade2c83fc5">Cy_PdStack_Dpm_ClearSolnBusy</a> (<a class="el" href="structcy__stc__pdstack__context__t.html">cy_stc_pdstack_context_t</a> *ptrPdStackContext)</td></tr>
<tr class="memdesc:ga1534293c5924a4148d9669ade2c83fc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to inform the Type-C/PD stack that the solution state allows Type-C transitions.  <a href="#ga1534293c5924a4148d9669ade2c83fc5">More...</a><br /></td></tr>
<tr class="separator:ga1534293c5924a4148d9669ade2c83fc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6bea08981f4ddf3f780383abc70f6fbd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__pdstack__functions.html#ga6bea08981f4ddf3f780383abc70f6fbd">Cy_PdStack_Dpm_SetSolnBusy</a> (<a class="el" href="structcy__stc__pdstack__context__t.html">cy_stc_pdstack_context_t</a> *ptrPdStackContext)</td></tr>
<tr class="memdesc:ga6bea08981f4ddf3f780383abc70f6fbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to inform the Type-C/PD stack that the solution state does not allow Type-C transitions.  <a href="#ga6bea08981f4ddf3f780383abc70f6fbd">More...</a><br /></td></tr>
<tr class="separator:ga6bea08981f4ddf3f780383abc70f6fbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa1854d1e382cdc8a5880e525f516a40b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__pdstack__enums.html#ga2115782809414a20b28e6f5df83b7a7f">cy_en_pdstack_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__pdstack__functions.html#gaa1854d1e382cdc8a5880e525f516a40b">Cy_PdStack_Dpm_ChangeEprActiveFlag</a> (<a class="el" href="structcy__stc__pdstack__context__t.html">cy_stc_pdstack_context_t</a> *ptrPdStackContext, bool flag)</td></tr>
<tr class="memdesc:gaa1854d1e382cdc8a5880e525f516a40b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to change state of EPR mode active flag.  <a href="#gaa1854d1e382cdc8a5880e525f516a40b">More...</a><br /></td></tr>
<tr class="separator:gaa1854d1e382cdc8a5880e525f516a40b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8323fef1fdb62cf478844a4d43f5cff8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__pdstack__enums.html#ga2115782809414a20b28e6f5df83b7a7f">cy_en_pdstack_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__pdstack__functions.html#ga8323fef1fdb62cf478844a4d43f5cff8">Cy_PdStack_Dpm_IsEprModeActive</a> (<a class="el" href="structcy__stc__pdstack__context__t.html">cy_stc_pdstack_context_t</a> *ptrPdStackContext, bool *isActive)</td></tr>
<tr class="memdesc:ga8323fef1fdb62cf478844a4d43f5cff8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to check whether EPR mode is active.  <a href="#ga8323fef1fdb62cf478844a4d43f5cff8">More...</a><br /></td></tr>
<tr class="separator:ga8323fef1fdb62cf478844a4d43f5cff8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9f31ce68e71ac99956956f429ae2d27"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__pdstack__enums.html#ga2115782809414a20b28e6f5df83b7a7f">cy_en_pdstack_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__pdstack__functions.html#gaf9f31ce68e71ac99956956f429ae2d27">Cy_PdStack_Dpm_ChangeEprToSpr</a> (<a class="el" href="structcy__stc__pdstack__context__t.html">cy_stc_pdstack_context_t</a> *ptrPdStackContext, bool flag)</td></tr>
<tr class="memdesc:gaf9f31ce68e71ac99956956f429ae2d27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function changes the EPR to SPR indicator.  <a href="#gaf9f31ce68e71ac99956956f429ae2d27">More...</a><br /></td></tr>
<tr class="separator:gaf9f31ce68e71ac99956956f429ae2d27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad7f62cf570d855402af0a004702f5adb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__pdstack__enums.html#ga2115782809414a20b28e6f5df83b7a7f">cy_en_pdstack_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__pdstack__functions.html#gad7f62cf570d855402af0a004702f5adb">Cy_PdStack_Dpm_IsEprSpr</a> (<a class="el" href="structcy__stc__pdstack__context__t.html">cy_stc_pdstack_context_t</a> *ptrPdStackContext, bool *isSpr)</td></tr>
<tr class="memdesc:gad7f62cf570d855402af0a004702f5adb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function checks whether the EPR pdo needs to limit it to SPR.  <a href="#gad7f62cf570d855402af0a004702f5adb">More...</a><br /></td></tr>
<tr class="separator:gad7f62cf570d855402af0a004702f5adb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae911bf71e2bf34e10ddead31588d74b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__pdstack__enums.html#ga2115782809414a20b28e6f5df83b7a7f">cy_en_pdstack_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__pdstack__functions.html#gaae911bf71e2bf34e10ddead31588d74b">Cy_PdStack_Dpm_IsEprAvsModeActive</a> (<a class="el" href="structcy__stc__pdstack__context__t.html">cy_stc_pdstack_context_t</a> *ptrPdStackContext, bool *isActive)</td></tr>
<tr class="memdesc:gaae911bf71e2bf34e10ddead31588d74b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to check whether EPR AVS mode is active.  <a href="#gaae911bf71e2bf34e10ddead31588d74b">More...</a><br /></td></tr>
<tr class="separator:gaae911bf71e2bf34e10ddead31588d74b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1df6fdf79498cef6df1815bbdee6248b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__pdstack__enums.html#ga2115782809414a20b28e6f5df83b7a7f">cy_en_pdstack_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__pdstack__functions.html#ga1df6fdf79498cef6df1815bbdee6248b">Cy_PdStack_Dpm_ChangeEprAvsActiveFlag</a> (<a class="el" href="structcy__stc__pdstack__context__t.html">cy_stc_pdstack_context_t</a> *ptrPdStackContext, bool flag)</td></tr>
<tr class="memdesc:ga1df6fdf79498cef6df1815bbdee6248b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to change state of EPR AVS mode active flag.  <a href="#ga1df6fdf79498cef6df1815bbdee6248b">More...</a><br /></td></tr>
<tr class="separator:ga1df6fdf79498cef6df1815bbdee6248b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe86f56a7117cd31bf55f25ebc706e1c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__pdstack__enums.html#ga2115782809414a20b28e6f5df83b7a7f">cy_en_pdstack_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__pdstack__functions.html#gabe86f56a7117cd31bf55f25ebc706e1c">Cy_PdStack_Dpm_IsValidAvsReq</a> (<a class="el" href="structcy__stc__pdstack__context__t.html">cy_stc_pdstack_context_t</a> *ptrPdStackContext, uint8_t src_pdo_index, cy_pd_pd_do_t rdo)</td></tr>
<tr class="memdesc:gabe86f56a7117cd31bf55f25ebc706e1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to change state of EPR AVS mode active flag.  <a href="#gabe86f56a7117cd31bf55f25ebc706e1c">More...</a><br /></td></tr>
<tr class="separator:gabe86f56a7117cd31bf55f25ebc706e1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac66faebea2dbaf5915cf59d71bc94454"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__pdstack__functions.html#gac66faebea2dbaf5915cf59d71bc94454">Cy_PdStack_Dpm_EprSnkSendKeepAliveCb</a> (<a class="el" href="group__group__pdstack__data__structures.html#ga87a37816b1bb27d6ab0f583a1ac01cdd">cy_timer_id_t</a> id, void *ptrContext)</td></tr>
<tr class="memdesc:gac66faebea2dbaf5915cf59d71bc94454"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function callback to initiate Keep Alive message.  <a href="#gac66faebea2dbaf5915cf59d71bc94454">More...</a><br /></td></tr>
<tr class="separator:gac66faebea2dbaf5915cf59d71bc94454"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff5593f490badca6dc53a2d5b9941ea7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__pdstack__enums.html#ga2115782809414a20b28e6f5df83b7a7f">cy_en_pdstack_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__pdstack__functions.html#gaff5593f490badca6dc53a2d5b9941ea7">Cy_PdStack_Dpm_UpdateSnkMaxMin</a> (<a class="el" href="structcy__stc__pdstack__context__t.html">cy_stc_pdstack_context_t</a> *ptrPdStackContext, uint8_t count, uint16_t *max_min)</td></tr>
<tr class="memdesc:gaff5593f490badca6dc53a2d5b9941ea7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to update the sink max/min current/power at runtime thereby overriding the generated configuration by EZ-PD Configurator.  <a href="#gaff5593f490badca6dc53a2d5b9941ea7">More...</a><br /></td></tr>
<tr class="separator:gaff5593f490badca6dc53a2d5b9941ea7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacfa6c9ebe83b586dc059244db086ed95"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__pdstack__enums.html#ga2115782809414a20b28e6f5df83b7a7f">cy_en_pdstack_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__pdstack__functions.html#gacfa6c9ebe83b586dc059244db086ed95">Cy_PdStack_Dpm_UpdateSnkCapMask</a> (<a class="el" href="structcy__stc__pdstack__context__t.html">cy_stc_pdstack_context_t</a> *ptrPdStackContext, uint8_t mask)</td></tr>
<tr class="memdesc:gacfa6c9ebe83b586dc059244db086ed95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to update the sink PDO mask at runtime thereby overriding the generated configuration by EZ-PD Configurator.  <a href="#gacfa6c9ebe83b586dc059244db086ed95">More...</a><br /></td></tr>
<tr class="separator:gacfa6c9ebe83b586dc059244db086ed95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2dd874498d2c7b9e16748935541442a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__pdstack__enums.html#ga2115782809414a20b28e6f5df83b7a7f">cy_en_pdstack_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__pdstack__functions.html#gae2dd874498d2c7b9e16748935541442a">Cy_PdStack_Dpm_UpdateSnkCap</a> (<a class="el" href="structcy__stc__pdstack__context__t.html">cy_stc_pdstack_context_t</a> *ptrPdStackContext, uint8_t count, cy_pd_pd_do_t *pdo)</td></tr>
<tr class="memdesc:gae2dd874498d2c7b9e16748935541442a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to update the sink PDOs at runtime thereby overriding the generated configuration by EZ-PD Configurator.  <a href="#gae2dd874498d2c7b9e16748935541442a">More...</a><br /></td></tr>
<tr class="separator:gae2dd874498d2c7b9e16748935541442a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29165181d3ace6983fe11f11decd9254"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__pdstack__enums.html#ga2115782809414a20b28e6f5df83b7a7f">cy_en_pdstack_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__pdstack__functions.html#ga29165181d3ace6983fe11f11decd9254">Cy_PdStack_Dpm_UpdateSrcCapMask</a> (<a class="el" href="structcy__stc__pdstack__context__t.html">cy_stc_pdstack_context_t</a> *ptrPdStackContext, uint8_t mask)</td></tr>
<tr class="memdesc:ga29165181d3ace6983fe11f11decd9254"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to update the source PDO mask at runtime thereby overriding the generated configuration by EZ-PD Configurator.  <a href="#ga29165181d3ace6983fe11f11decd9254">More...</a><br /></td></tr>
<tr class="separator:ga29165181d3ace6983fe11f11decd9254"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef57a1fc49e793766fd7f091dcdfddd8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__pdstack__enums.html#ga2115782809414a20b28e6f5df83b7a7f">cy_en_pdstack_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__pdstack__functions.html#gaef57a1fc49e793766fd7f091dcdfddd8">Cy_PdStack_Dpm_UpdateSrcCap</a> (<a class="el" href="structcy__stc__pdstack__context__t.html">cy_stc_pdstack_context_t</a> *ptrPdStackContext, uint8_t count, cy_pd_pd_do_t *pdo)</td></tr>
<tr class="memdesc:gaef57a1fc49e793766fd7f091dcdfddd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to update the source PDOs at runtime thereby overriding the generated configuration by EZ-PD Configurator.  <a href="#gaef57a1fc49e793766fd7f091dcdfddd8">More...</a><br /></td></tr>
<tr class="separator:gaef57a1fc49e793766fd7f091dcdfddd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga81d70dcf068687970e99777d6119955a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__pdstack__enums.html#ga2115782809414a20b28e6f5df83b7a7f">cy_en_pdstack_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__pdstack__functions.html#ga81d70dcf068687970e99777d6119955a">Cy_PdStack_Dpm_UpdateEprSnkCap</a> (<a class="el" href="structcy__stc__pdstack__context__t.html">cy_stc_pdstack_context_t</a> *ptrPdStackContext, uint8_t count, cy_pd_pd_do_t *pdo)</td></tr>
<tr class="memdesc:ga81d70dcf068687970e99777d6119955a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to update the EPR sink PDOs at runtime thereby overriding the generated configuration by EZ-PD Configurator.  <a href="#ga81d70dcf068687970e99777d6119955a">More...</a><br /></td></tr>
<tr class="separator:ga81d70dcf068687970e99777d6119955a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga96e4125b87b56935a6772547091d19b3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__pdstack__enums.html#ga2115782809414a20b28e6f5df83b7a7f">cy_en_pdstack_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__pdstack__functions.html#ga96e4125b87b56935a6772547091d19b3">Cy_PdStack_Dpm_UpdateEprSnkCapMask</a> (<a class="el" href="structcy__stc__pdstack__context__t.html">cy_stc_pdstack_context_t</a> *ptrPdStackContext, uint8_t mask)</td></tr>
<tr class="memdesc:ga96e4125b87b56935a6772547091d19b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to update the EPR sink PDO mask at runtime thereby overriding the generated configuration by EZ-PD Configurator.  <a href="#ga96e4125b87b56935a6772547091d19b3">More...</a><br /></td></tr>
<tr class="separator:ga96e4125b87b56935a6772547091d19b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga571254a255a639c850955f2ee44a4ff6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__pdstack__functions.html#ga571254a255a639c850955f2ee44a4ff6">cy_sw_timer_init</a> (<a class="el" href="structcy__stc__sw__timer__t.html">cy_stc_sw_timer_t</a> *context, uint32_t sysClkFreq)</td></tr>
<tr class="memdesc:ga571254a255a639c850955f2ee44a4ff6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function initializes the software timer module.  <a href="#ga571254a255a639c850955f2ee44a4ff6">More...</a><br /></td></tr>
<tr class="separator:ga571254a255a639c850955f2ee44a4ff6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f7d0de989622862b23e48dd59ea4fcc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__pdstack__functions.html#ga4f7d0de989622862b23e48dd59ea4fcc">cy_sw_timer_start</a> (<a class="el" href="structcy__stc__sw__timer__t.html">cy_stc_sw_timer_t</a> *context, void *callbackContext, <a class="el" href="group__group__pdstack__data__structures.html#ga87a37816b1bb27d6ab0f583a1ac01cdd">cy_timer_id_t</a> id, uint16_t period, <a class="el" href="group__group__pdstack__data__structures.html#ga677655f9c592cb223c59bf38678c1a1a">cy_cb_timer_t</a> cb)</td></tr>
<tr class="memdesc:ga4f7d0de989622862b23e48dd59ea4fcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start a specific soft timer.  <a href="#ga4f7d0de989622862b23e48dd59ea4fcc">More...</a><br /></td></tr>
<tr class="separator:ga4f7d0de989622862b23e48dd59ea4fcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1fa158c30f555b378dc841b4964a34bd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__pdstack__functions.html#ga1fa158c30f555b378dc841b4964a34bd">cy_sw_timer_start_wocb</a> (<a class="el" href="structcy__stc__sw__timer__t.html">cy_stc_sw_timer_t</a> *context, <a class="el" href="group__group__pdstack__data__structures.html#ga87a37816b1bb27d6ab0f583a1ac01cdd">cy_timer_id_t</a> id, uint16_t period)</td></tr>
<tr class="memdesc:ga1fa158c30f555b378dc841b4964a34bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start a specific soft timer without providing a callback for expiry notification.  <a href="#ga1fa158c30f555b378dc841b4964a34bd">More...</a><br /></td></tr>
<tr class="separator:ga1fa158c30f555b378dc841b4964a34bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3006fefdec6f3e5cc0ba40533ebd90e1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__pdstack__functions.html#ga3006fefdec6f3e5cc0ba40533ebd90e1">cy_sw_timer_stop</a> (<a class="el" href="structcy__stc__sw__timer__t.html">cy_stc_sw_timer_t</a> *context, <a class="el" href="group__group__pdstack__data__structures.html#ga87a37816b1bb27d6ab0f583a1ac01cdd">cy_timer_id_t</a> id)</td></tr>
<tr class="memdesc:ga3006fefdec6f3e5cc0ba40533ebd90e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stop a soft timer which is currently running.  <a href="#ga3006fefdec6f3e5cc0ba40533ebd90e1">More...</a><br /></td></tr>
<tr class="separator:ga3006fefdec6f3e5cc0ba40533ebd90e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6de412b66324addf487bed9fda267f3e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__pdstack__functions.html#ga6de412b66324addf487bed9fda267f3e">cy_sw_timer_is_running</a> (<a class="el" href="structcy__stc__sw__timer__t.html">cy_stc_sw_timer_t</a> *context, <a class="el" href="group__group__pdstack__data__structures.html#ga87a37816b1bb27d6ab0f583a1ac01cdd">cy_timer_id_t</a> id)</td></tr>
<tr class="memdesc:ga6de412b66324addf487bed9fda267f3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether the specified soft timer is currently running.  <a href="#ga6de412b66324addf487bed9fda267f3e">More...</a><br /></td></tr>
<tr class="separator:ga6de412b66324addf487bed9fda267f3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga729796ffbdea922f8e5a7fd5f321cd0d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__pdstack__functions.html#ga729796ffbdea922f8e5a7fd5f321cd0d">cy_sw_timer_range_enabled</a> (<a class="el" href="structcy__stc__sw__timer__t.html">cy_stc_sw_timer_t</a> *context, <a class="el" href="group__group__pdstack__data__structures.html#ga87a37816b1bb27d6ab0f583a1ac01cdd">cy_timer_id_t</a> low, <a class="el" href="group__group__pdstack__data__structures.html#ga87a37816b1bb27d6ab0f583a1ac01cdd">cy_timer_id_t</a> high)</td></tr>
<tr class="memdesc:ga729796ffbdea922f8e5a7fd5f321cd0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether the any of the soft timers in the specified range are currently running.  <a href="#ga729796ffbdea922f8e5a7fd5f321cd0d">More...</a><br /></td></tr>
<tr class="separator:ga729796ffbdea922f8e5a7fd5f321cd0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61adc4b2eb587c1a2ae7b2e87dfa3072"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__pdstack__functions.html#ga61adc4b2eb587c1a2ae7b2e87dfa3072">cy_sw_timer_get_count</a> (<a class="el" href="structcy__stc__sw__timer__t.html">cy_stc_sw_timer_t</a> *context, <a class="el" href="group__group__pdstack__data__structures.html#ga87a37816b1bb27d6ab0f583a1ac01cdd">cy_timer_id_t</a> id)</td></tr>
<tr class="memdesc:ga61adc4b2eb587c1a2ae7b2e87dfa3072"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the time (in ms) remaining for timer expiration.  <a href="#ga61adc4b2eb587c1a2ae7b2e87dfa3072">More...</a><br /></td></tr>
<tr class="separator:ga61adc4b2eb587c1a2ae7b2e87dfa3072"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d12d06f621bb1dd95fcbd011516682f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__pdstack__functions.html#ga4d12d06f621bb1dd95fcbd011516682f">cy_sw_timer_stop_all</a> (<a class="el" href="structcy__stc__sw__timer__t.html">cy_stc_sw_timer_t</a> *context)</td></tr>
<tr class="memdesc:ga4d12d06f621bb1dd95fcbd011516682f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stops all active soft timers.  <a href="#ga4d12d06f621bb1dd95fcbd011516682f">More...</a><br /></td></tr>
<tr class="separator:ga4d12d06f621bb1dd95fcbd011516682f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa9ff160349cf0db1ab09fc42eeafe57b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__pdstack__functions.html#gaa9ff160349cf0db1ab09fc42eeafe57b">cy_sw_timer_stop_range</a> (<a class="el" href="structcy__stc__sw__timer__t.html">cy_stc_sw_timer_t</a> *context, <a class="el" href="group__group__pdstack__data__structures.html#ga87a37816b1bb27d6ab0f583a1ac01cdd">cy_timer_id_t</a> start, <a class="el" href="group__group__pdstack__data__structures.html#ga87a37816b1bb27d6ab0f583a1ac01cdd">cy_timer_id_t</a> end)</td></tr>
<tr class="memdesc:gaa9ff160349cf0db1ab09fc42eeafe57b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function stops all soft timers with ids in the specified range.  <a href="#gaa9ff160349cf0db1ab09fc42eeafe57b">More...</a><br /></td></tr>
<tr class="separator:gaa9ff160349cf0db1ab09fc42eeafe57b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaece137e47862aa5d0b40edf013a71738"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__pdstack__functions.html#gaece137e47862aa5d0b40edf013a71738">cy_sw_timer_num_active</a> (<a class="el" href="structcy__stc__sw__timer__t.html">cy_stc_sw_timer_t</a> *context)</td></tr>
<tr class="memdesc:gaece137e47862aa5d0b40edf013a71738"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns number of active timers.  <a href="#gaece137e47862aa5d0b40edf013a71738">More...</a><br /></td></tr>
<tr class="separator:gaece137e47862aa5d0b40edf013a71738"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga28d1dbbc963e015cd3689f8a4263e425"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__pdstack__functions.html#ga28d1dbbc963e015cd3689f8a4263e425">cy_sw_timer_enter_sleep</a> (<a class="el" href="structcy__stc__sw__timer__t.html">cy_stc_sw_timer_t</a> *context)</td></tr>
<tr class="memdesc:ga28d1dbbc963e015cd3689f8a4263e425"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function prepares the timer module and the hardware timer for entering device deep sleep.  <a href="#ga28d1dbbc963e015cd3689f8a4263e425">More...</a><br /></td></tr>
<tr class="separator:ga28d1dbbc963e015cd3689f8a4263e425"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga548d2c906554c3e70bf1e25a7feeb111"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__pdstack__functions.html#ga548d2c906554c3e70bf1e25a7feeb111">cy_sw_timer_interrupt_handler</a> (<a class="el" href="structcy__stc__sw__timer__t.html">cy_stc_sw_timer_t</a> *context)</td></tr>
<tr class="memdesc:ga548d2c906554c3e70bf1e25a7feeb111"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function implements the interrupt handler callback used by the Soft Timer module, and is expected to be called by the application whenever the appropriate SysTick or WDT interrupt is received.  <a href="#ga548d2c906554c3e70bf1e25a7feeb111">More...</a><br /></td></tr>
<tr class="separator:ga548d2c906554c3e70bf1e25a7feeb111"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5caa507456d28bdc2941796cead1bbe9"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__pdstack__functions.html#ga5caa507456d28bdc2941796cead1bbe9">cy_sw_timer_get_multiplier</a> (<a class="el" href="structcy__stc__sw__timer__t.html">cy_stc_sw_timer_t</a> *context)</td></tr>
<tr class="memdesc:ga5caa507456d28bdc2941796cead1bbe9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function retrieves the number of low frequency (LF) clock ticks required per ms.  <a href="#ga5caa507456d28bdc2941796cead1bbe9">More...</a><br /></td></tr>
<tr class="separator:ga5caa507456d28bdc2941796cead1bbe9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga201503833db097afe5c9e0d18e8e03ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga201503833db097afe5c9e0d18e8e03ea">&#9670;&nbsp;</a></span>Cy_PdStack_Dpm_Init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__pdstack__enums.html#ga2115782809414a20b28e6f5df83b7a7f">cy_en_pdstack_status_t</a> Cy_PdStack_Dpm_Init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcy__stc__pdstack__context__t.html">cy_stc_pdstack_context_t</a> *&#160;</td>
          <td class="paramname"><em>ptrPdStackContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cy_stc_usbpd_context_t *&#160;</td>
          <td class="paramname"><em>ptrUsbPdContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcy__stc__pdstack__port__cfg__t.html">cy_stc_pdstack_port_cfg_t</a> *&#160;</td>
          <td class="paramname"><em>ptrPortCfg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcy__stc__pdstack__app__cbk__t.html">cy_stc_pdstack_app_cbk_t</a> *&#160;</td>
          <td class="paramname"><em>ptrAppCbk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcy__stc__pdstack__dpm__params__t.html">cy_stc_pdstack_dpm_params_t</a> *&#160;</td>
          <td class="paramname"><em>ptrDpmParams</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcy__stc__sw__timer__t.html">cy_stc_sw_timer_t</a> *&#160;</td>
          <td class="paramname"><em>ptrTimerContext</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function initializes the device policy manager with callback pointers and loads the port configuration information from the port config table. </p>
<p>This function also initializes the PD policy engine and Type-C connection manager.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptrPdStackContext</td><td>PdStack Library Context pointer.</td></tr>
    <tr><td class="paramname">ptrUsbPdContext</td><td>UsbPd Driver Context pointer.</td></tr>
    <tr><td class="paramname">ptrPortCfg</td><td>Port Configuration pointer.</td></tr>
    <tr><td class="paramname">ptrAppCbk</td><td>Application callback function pointer.</td></tr>
    <tr><td class="paramname">ptrDpmParams</td><td>Pointer to the DPM parameter information structure.</td></tr>
    <tr><td class="paramname">ptrTimerContext</td><td>Pointer to soft timer context structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_PDSTACK_STAT_SUCCESS if operation is successful CY_PDSTACK_STAT_BAD_PARAM if the input parameters are not valid </dd></dl>

</div>
</div>
<a id="gaae9893510cb213c6b799bb490b76d513"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaae9893510cb213c6b799bb490b76d513">&#9670;&nbsp;</a></span>Cy_PdStack_Dpm_Start()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__pdstack__enums.html#ga2115782809414a20b28e6f5df83b7a7f">cy_en_pdstack_status_t</a> Cy_PdStack_Dpm_Start </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcy__stc__pdstack__context__t.html">cy_stc_pdstack_context_t</a> *&#160;</td>
          <td class="paramname"><em>ptrPdStackContext</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function makes the specified USB Type-C port operational. </p>
<p>The port to be updated is specified by passing the PD Stack context corresponding to it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptrPdStackContext</td><td>PdStack Library Context pointer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_PDSTACK_STAT_SUCCESS if operation is successful CY_PDSTACK_STAT_BAD_PARAM if the context pointer is invalid CY_PDSTACK_STAT_FAILURE if the operation fails. </dd></dl>

</div>
</div>
<a id="ga67ca2bbf457f4a9777dc121eb53f445b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga67ca2bbf457f4a9777dc121eb53f445b">&#9670;&nbsp;</a></span>Cy_PdStack_Dpm_Stop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__pdstack__enums.html#ga2115782809414a20b28e6f5df83b7a7f">cy_en_pdstack_status_t</a> Cy_PdStack_Dpm_Stop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcy__stc__pdstack__context__t.html">cy_stc_pdstack_context_t</a> *&#160;</td>
          <td class="paramname"><em>ptrPdStackContext</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function stops the port operation. </p>
<p>The USBPD block corresponding to the port will be disabled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptrPdStackContext</td><td>PdStack Library Context pointer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_PDSTACK_STAT_SUCCESS if operation is successful CY_PDSTACK_STAT_BAD_PARAM if the context pointer is invalid CY_PDSTACK_STAT_FAILURE if the operation fails. </dd></dl>

</div>
</div>
<a id="ga5b02e2958684a052e39ec007b2f646e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5b02e2958684a052e39ec007b2f646e1">&#9670;&nbsp;</a></span>Cy_PdStack_Dpm_Disable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__pdstack__enums.html#ga2115782809414a20b28e6f5df83b7a7f">cy_en_pdstack_status_t</a> Cy_PdStack_Dpm_Disable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcy__stc__pdstack__context__t.html">cy_stc_pdstack_context_t</a> *&#160;</td>
          <td class="paramname"><em>ptrPdStackContext</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function disables the PD port operation and limits it to receiving hard reset signalling. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptrPdStackContext</td><td>PdStack Library Context pointer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_PDSTACK_STAT_SUCCESS if operation is successful CY_PDSTACK_STAT_BAD_PARAM if the context pointer is invalid CY_PDSTACK_STAT_FAILURE if the operation fails. </dd></dl>

</div>
</div>
<a id="ga8d640baff9e0b6140d80b4ed2c41aa1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8d640baff9e0b6140d80b4ed2c41aa1c">&#9670;&nbsp;</a></span>Cy_PdStack_Dpm_PrepareDeepSleep()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__pdstack__enums.html#ga2115782809414a20b28e6f5df83b7a7f">cy_en_pdstack_status_t</a> Cy_PdStack_Dpm_PrepareDeepSleep </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcy__stc__pdstack__context__t.html">cy_stc_pdstack_context_t</a> *&#160;</td>
          <td class="paramname"><em>ptrPdStackContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>ptrDeepSleep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function configures the PD policy manager and Type-C manager state machines to allow the PMG1 device to be placed in deep sleep. </p>
<p>If the state machines are not in a busy state, the USBPD block is configured to trigger a wake-up interrupt on any activity and the location pointed by ptrDeepSleep is set to true. If the state machines are busy, the location pointed by ptrDeepSleep is set to false to indicate that the PMG1 device shall not proceed into deep sleep.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptrPdStackContext</td><td>PdStack Library Context pointer.</td></tr>
    <tr><td class="paramname">ptrDeepSleep</td><td>Output parameter contains true if deepsleep is possible and configured, otherwise false</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_PDSTACK_STAT_SUCCESS if operation is successful CY_PDSTACK_STAT_BAD_PARAM if the context pointer or the ptrDeepSleep is invalid CY_PDSTACK_STAT_FAILURE if the operation fails. </dd></dl>

</div>
</div>
<a id="gac5de1c7b55d33cd596b43dcf222ffd8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac5de1c7b55d33cd596b43dcf222ffd8c">&#9670;&nbsp;</a></span>Cy_PdStack_Dpm_Resume()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__pdstack__enums.html#ga2115782809414a20b28e6f5df83b7a7f">cy_en_pdstack_status_t</a> Cy_PdStack_Dpm_Resume </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcy__stc__pdstack__context__t.html">cy_stc_pdstack_context_t</a> *&#160;</td>
          <td class="paramname"><em>ptrPdStackContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>ptrResume</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function resumes the Type-C manager and PD policy engine state machines after the PMG1 device has woken up from deep sleep. </p>
<p>This function needs to be called to resume the stack operation if Cy_PdStack_Dpm_PrepareDeepSleep has previously been called and returned true. This needs to be done even if the PMG1 device did not actually go into deep sleep due to other reasons.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptrPdStackContext</td><td>PdStack Library Context pointer.</td></tr>
    <tr><td class="paramname">ptrResume</td><td>Output parameter contains true if successful otherwise false</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_PDSTACK_STAT_SUCCESS if operation is successful CY_PDSTACK_STAT_BAD_PARAM if the context pointer or the ptrResume is invalid </dd></dl>

</div>
</div>
<a id="ga242623fe6b5efbf33c83ab3c3323e7be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga242623fe6b5efbf33c83ab3c3323e7be">&#9670;&nbsp;</a></span>Cy_PdStack_Dpm_IsSleepAllowed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__pdstack__enums.html#ga2115782809414a20b28e6f5df83b7a7f">cy_en_pdstack_status_t</a> Cy_PdStack_Dpm_IsSleepAllowed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcy__stc__pdstack__context__t.html">cy_stc_pdstack_context_t</a> *&#160;</td>
          <td class="paramname"><em>ptrPdStackContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>ptrSleepAllowed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function checks if the PD policy engine and Type-C manager state machines corresponding to the specified Type-C port are idle. </p>
<p>If this function indicates that the state machines are busy, deep sleep entry using the Cy_PdStack_Dpm_PrepareDeepSleep should not be attempted.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptrPdStackContext</td><td>PdStack Library Context pointer.</td></tr>
    <tr><td class="paramname">ptrSleepAllowed</td><td>Output parameter contains true if possible to go into sleep mode, otherwise false</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_PDSTACK_STAT_SUCCESS if operation is successful CY_PDSTACK_STAT_BAD_PARAM if the context pointer or the ptrSleepAllowed is invalid </dd></dl>

</div>
</div>
<a id="ga6351a34299af47084a316107294a50a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6351a34299af47084a316107294a50a1">&#9670;&nbsp;</a></span>Cy_PdStack_Dpm_Rtos_Init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__pdstack__enums.html#ga2115782809414a20b28e6f5df83b7a7f">cy_en_pdstack_status_t</a> Cy_PdStack_Dpm_Rtos_Init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcy__stc__pdstack__context__t.html">cy_stc_pdstack_context_t</a> *&#160;</td>
          <td class="paramname"><em>ptrPdStackContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcy__stc__pdstack__rtos__context__t.html">cy_stc_pdstack_rtos_context_t</a> *&#160;</td>
          <td class="paramname"><em>ptrRtosContext</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function initializes the device policy manager with RTOS context details. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptrPdStackContext</td><td>PdStack Library Context pointer.</td></tr>
    <tr><td class="paramname">ptrRtosContext</td><td>Pointer to RTOS API's callback context</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_PDSTACK_STAT_SUCCESS if operation is successful CY_PDSTACK_STAT_BAD_PARAM if the input parameters are not valid </dd></dl>

</div>
</div>
<a id="gaa7461e8739b31c7c212e2af74f230c80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa7461e8739b31c7c212e2af74f230c80">&#9670;&nbsp;</a></span>Cy_PdStack_Dpm_Task()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__pdstack__enums.html#ga2115782809414a20b28e6f5df83b7a7f">cy_en_pdstack_status_t</a> Cy_PdStack_Dpm_Task </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcy__stc__pdstack__context__t.html">cy_stc_pdstack_context_t</a> *&#160;</td>
          <td class="paramname"><em>ptrPdStackContext</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function runs the Type-C manager and PD policy manager tasks for the specified port. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptrPdStackContext</td><td>PdStack Library Context pointer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_PDSTACK_STAT_SUCCESS if operation is successful CY_PDSTACK_STAT_BAD_PARAM if the context pointer is invalid </dd></dl>

</div>
</div>
<a id="ga5899a0d50296f6656ed39a13fedf68b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5899a0d50296f6656ed39a13fedf68b3">&#9670;&nbsp;</a></span>Cy_PdStack_Dpm_SendPdCommand()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__pdstack__enums.html#ga2115782809414a20b28e6f5df83b7a7f">cy_en_pdstack_status_t</a> Cy_PdStack_Dpm_SendPdCommand </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcy__stc__pdstack__context__t.html">cy_stc_pdstack_context_t</a> *&#160;</td>
          <td class="paramname"><em>ptrPdStackContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__pdstack__enums.html#gaab347ed9d4ea3174377c728e9304fa27">cy_en_pdstack_dpm_pd_cmd_t</a>&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcy__stc__pdstack__dpm__pd__cmd__buf__t.html">cy_stc_pdstack_dpm_pd_cmd_buf_t</a> *&#160;</td>
          <td class="paramname"><em>ptrCmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isResp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__pdstack__data__structures.html#ga8032135e3e0bcc286f569781a51f50a2">cy_pdstack_dpm_pd_cmd_cbk_t</a>&#160;</td>
          <td class="paramname"><em>cmdCbk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function provides an interface for the application module to send PD commands. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptrPdStackContext</td><td>PdStack Library Context pointer.</td></tr>
    <tr><td class="paramname">cmd</td><td>Type of command to be initiated.</td></tr>
    <tr><td class="paramname">ptrCmdBuf</td><td>Pointer to the command buffer.</td></tr>
    <tr><td class="paramname">isResp</td><td>Set to true when the API is called to send a response to previously received PD messages.</td></tr>
    <tr><td class="paramname">cmdCbk</td><td>Pointer to the callback function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_PDSTACK_STAT_SUCCESS if the command is registered CY_PDSTACK_STAT_CMD_FAILURE if the PD port is not ready for a command CY_PDSTACK_STAT_BUSY if there is another pending command. CY_PDSTACK_STAT_BAD_PARAM if any of the parameters are invalid </dd></dl>

</div>
</div>
<a id="ga55149c2f22c57f73b1de2dd7a791ada5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga55149c2f22c57f73b1de2dd7a791ada5">&#9670;&nbsp;</a></span>Cy_PdStack_Dpm_SendTypecCommand()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__pdstack__enums.html#ga2115782809414a20b28e6f5df83b7a7f">cy_en_pdstack_status_t</a> Cy_PdStack_Dpm_SendTypecCommand </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcy__stc__pdstack__context__t.html">cy_stc_pdstack_context_t</a> *&#160;</td>
          <td class="paramname"><em>ptrPdStackContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__pdstack__enums.html#gaf1be4da8f6e2a81a74ba4248ae63fc62">cy_en_pdstack_dpm_typec_cmd_t</a>&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__pdstack__data__structures.html#ga3f4fb1cb7b6b853659e8d2ea7db20884">cy_pdstack_dpm_typec_cmd_cbk_t</a>&#160;</td>
          <td class="paramname"><em>cmdCbk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function provides an interface for the application module to send commands to the Type-C connection manager. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptrPdStackContext</td><td>PdStack Library Context pointer.</td></tr>
    <tr><td class="paramname">cmd</td><td>Type of command to be performed.</td></tr>
    <tr><td class="paramname">cmdCbk</td><td>Pointer to the callback function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_PDSTACK_STAT_SUCCESS if the command is registered CY_PDSTACK_STAT_CMD_FAILURE if the PD port is not ready for a command CY_PDSTACK_STAT_BUSY if there is another pending command. CY_PDSTACK_STAT_BAD_PARAM if any of the parameters are invalid </dd></dl>

</div>
</div>
<a id="ga83cc6a82b07642504b719a809811018e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga83cc6a82b07642504b719a809811018e">&#9670;&nbsp;</a></span>Cy_PdStack_Dpm_ProtReset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__pdstack__enums.html#ga2115782809414a20b28e6f5df83b7a7f">cy_en_pdstack_status_t</a> Cy_PdStack_Dpm_ProtReset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcy__stc__pdstack__context__t.html">cy_stc_pdstack_context_t</a> *&#160;</td>
          <td class="paramname"><em>ptrPdStackContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cy_en_pd_sop_t&#160;</td>
          <td class="paramname"><em>sop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function resets PD protocol layer (transmit and receive) message ID counters for the specified PD packet type. </p>
<p>The message ID will be set to zero on the next PD message transmitted by PMG1. Message ID checks will not be performed for the next PD message of this type which is received by PMG1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptrPdStackContext</td><td>PdStack Library Context pointer.</td></tr>
    <tr><td class="paramname">sop</td><td>Packet type (SOP, SOP' or SOP'')</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_PDSTACK_STAT_SUCCESS if operation is successful CY_PDSTACK_STAT_BAD_PARAM if the context parameter is or sop value is invalid </dd></dl>

</div>
</div>
<a id="gad6e5f920dff34b6786198a006302d2fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad6e5f920dff34b6786198a006302d2fb">&#9670;&nbsp;</a></span>Cy_PdStack_Dpm_ProtResetRx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__pdstack__enums.html#ga2115782809414a20b28e6f5df83b7a7f">cy_en_pdstack_status_t</a> Cy_PdStack_Dpm_ProtResetRx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcy__stc__pdstack__context__t.html">cy_stc_pdstack_context_t</a> *&#160;</td>
          <td class="paramname"><em>ptrPdStackContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cy_en_pd_sop_t&#160;</td>
          <td class="paramname"><em>sop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function resets the PD receive message counter for the specified packet type. </p>
<p>This will cause the stack to skip checking for valid message ID on the next PD message of this type which is received.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptrPdStackContext</td><td>PdStack Library Context pointer.</td></tr>
    <tr><td class="paramname">sop</td><td>Packet type (SOP, SOP' or SOP'')</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_PDSTACK_STAT_SUCCESS if operation is successful CY_PDSTACK_STAT_BAD_PARAM if the context parameter or sop value is invalid </dd></dl>

</div>
</div>
<a id="ga0b1ec4633e71be2e67aa9b34a52283b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0b1ec4633e71be2e67aa9b34a52283b9">&#9670;&nbsp;</a></span>Cy_PdStack_Dpm_PeStop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__pdstack__enums.html#ga2115782809414a20b28e6f5df83b7a7f">cy_en_pdstack_status_t</a> Cy_PdStack_Dpm_PeStop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcy__stc__pdstack__context__t.html">cy_stc_pdstack_context_t</a> *&#160;</td>
          <td class="paramname"><em>ptrPdStackContext</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function stops the policy engine. </p>
<p>Used in a fault scenario where-in the USBPD communication needs to be stopped, but the Type-C manager needs to be active in order to detect detach of the faulty device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptrPdStackContext</td><td>PdStack Library Context pointer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_PDSTACK_STAT_SUCCESS if operation is successful CY_PDSTACK_STAT_BAD_PARAM if the context parameter is invalid </dd></dl>

</div>
</div>
<a id="ga649792612bdbf447fd5a80098014edf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga649792612bdbf447fd5a80098014edf3">&#9670;&nbsp;</a></span>Cy_PdStack_Dpm_Pd3SrcRpFlowControl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__pdstack__enums.html#ga2115782809414a20b28e6f5df83b7a7f">cy_en_pdstack_status_t</a> Cy_PdStack_Dpm_Pd3SrcRpFlowControl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcy__stc__pdstack__context__t.html">cy_stc_pdstack_context_t</a> *&#160;</td>
          <td class="paramname"><em>ptrPdStackContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>blockSinkAms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is used to specify whether we should keep the Rp termination at SinkTxNG or SinkTxOK while acting as a PD 3.0 source. </p>
<p>The PD policy engine has a default source implementation where it changes the Rp to SinkTxNG before sending any PD messages and reverts the Rp to SinkTxOK at the end of the AMS. This function can be used to speed up operation when initiating back-to-back AMS-es by preventing the Rp from being changed back to SinkTxOK after each AMS.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptrPdStackContext</td><td>PdStack Library Context pointer.</td></tr>
    <tr><td class="paramname">blockSinkAms</td><td>If true, Rp will be changed to SinkTxNG; if false, Rp will be changed to SinkTxOK.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_PDSTACK_STAT_SUCCESS if DUT is a PD 3.0 source CY_PDSTACK_STAT_CMD_FAILURE if DUT is not a PD 3.0 source. CY_PDSTACK_STAT_BAD_PARAM if the context parameter is invalid </dd></dl>

</div>
</div>
<a id="ga74d202e6caa7ed979d2429038462d53c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga74d202e6caa7ed979d2429038462d53c">&#9670;&nbsp;</a></span>Cy_PdStack_Dpm_IsIdle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__pdstack__enums.html#ga2115782809414a20b28e6f5df83b7a7f">cy_en_pdstack_status_t</a> Cy_PdStack_Dpm_IsIdle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcy__stc__pdstack__context__t.html">cy_stc_pdstack_context_t</a> *&#160;</td>
          <td class="paramname"><em>ptrPdStackContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>ptrIsIdle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to check whether the Type-C/PD stack is idle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptrPdStackContext</td><td>PdStack Library Context pointer.</td></tr>
    <tr><td class="paramname">ptrIsIdle</td><td>Output parameter contains true if idle, false if any operations are pending on any port.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_PDSTACK_STAT_SUCCESS if operation is successful, CY_PDSTACK_STAT_BAD_PARAM if the parameters are invalid. </dd></dl>

</div>
</div>
<a id="ga1534293c5924a4148d9669ade2c83fc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1534293c5924a4148d9669ade2c83fc5">&#9670;&nbsp;</a></span>Cy_PdStack_Dpm_ClearSolnBusy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_PdStack_Dpm_ClearSolnBusy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcy__stc__pdstack__context__t.html">cy_stc_pdstack_context_t</a> *&#160;</td>
          <td class="paramname"><em>ptrPdStackContext</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to inform the Type-C/PD stack that the solution state allows Type-C transitions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptrPdStackContext</td><td>PdStack Library Context pointer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="ga6bea08981f4ddf3f780383abc70f6fbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6bea08981f4ddf3f780383abc70f6fbd">&#9670;&nbsp;</a></span>Cy_PdStack_Dpm_SetSolnBusy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_PdStack_Dpm_SetSolnBusy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcy__stc__pdstack__context__t.html">cy_stc_pdstack_context_t</a> *&#160;</td>
          <td class="paramname"><em>ptrPdStackContext</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to inform the Type-C/PD stack that the solution state does not allow Type-C transitions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptrPdStackContext</td><td>PdStack Library Context pointer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="gaa1854d1e382cdc8a5880e525f516a40b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa1854d1e382cdc8a5880e525f516a40b">&#9670;&nbsp;</a></span>Cy_PdStack_Dpm_ChangeEprActiveFlag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__pdstack__enums.html#ga2115782809414a20b28e6f5df83b7a7f">cy_en_pdstack_status_t</a> Cy_PdStack_Dpm_ChangeEprActiveFlag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcy__stc__pdstack__context__t.html">cy_stc_pdstack_context_t</a> *&#160;</td>
          <td class="paramname"><em>ptrPdStackContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to change state of EPR mode active flag. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptrPdStackContext</td><td>PdStack Library Context pointer.</td></tr>
    <tr><td class="paramname">flag</td><td>sets/resets EPR active flag.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_PDSTACK_STAT_SUCCESS if operation is successful, CY_PDSTACK_STAT_BAD_PARAM if the parameters are invalid. </dd></dl>

</div>
</div>
<a id="ga8323fef1fdb62cf478844a4d43f5cff8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8323fef1fdb62cf478844a4d43f5cff8">&#9670;&nbsp;</a></span>Cy_PdStack_Dpm_IsEprModeActive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__pdstack__enums.html#ga2115782809414a20b28e6f5df83b7a7f">cy_en_pdstack_status_t</a> Cy_PdStack_Dpm_IsEprModeActive </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcy__stc__pdstack__context__t.html">cy_stc_pdstack_context_t</a> *&#160;</td>
          <td class="paramname"><em>ptrPdStackContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>isActive</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to check whether EPR mode is active. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptrPdStackContext</td><td>PdStack Library Context pointer.</td></tr>
    <tr><td class="paramname">isActive</td><td>State of EPR flag</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_PDSTACK_STAT_SUCCESS if operation is successful, CY_PDSTACK_STAT_BAD_PARAM if the parameters are invalid. </dd></dl>

</div>
</div>
<a id="gaf9f31ce68e71ac99956956f429ae2d27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf9f31ce68e71ac99956956f429ae2d27">&#9670;&nbsp;</a></span>Cy_PdStack_Dpm_ChangeEprToSpr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__pdstack__enums.html#ga2115782809414a20b28e6f5df83b7a7f">cy_en_pdstack_status_t</a> Cy_PdStack_Dpm_ChangeEprToSpr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcy__stc__pdstack__context__t.html">cy_stc_pdstack_context_t</a> *&#160;</td>
          <td class="paramname"><em>ptrPdStackContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function changes the EPR to SPR indicator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptrPdStackContext</td><td>PdStack Library Context pointer.</td></tr>
    <tr><td class="paramname">flag</td><td>sets/resets EPR flag to limit PDO index.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_PDSTACK_STAT_SUCCESS if operation is successful, CY_PDSTACK_STAT_BAD_PARAM if the parameters are invalid. </dd></dl>

</div>
</div>
<a id="gad7f62cf570d855402af0a004702f5adb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad7f62cf570d855402af0a004702f5adb">&#9670;&nbsp;</a></span>Cy_PdStack_Dpm_IsEprSpr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__pdstack__enums.html#ga2115782809414a20b28e6f5df83b7a7f">cy_en_pdstack_status_t</a> Cy_PdStack_Dpm_IsEprSpr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcy__stc__pdstack__context__t.html">cy_stc_pdstack_context_t</a> *&#160;</td>
          <td class="paramname"><em>ptrPdStackContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>isSpr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function checks whether the EPR pdo needs to limit it to SPR. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptrPdStackContext</td><td>PdStack Library Context pointer.</td></tr>
    <tr><td class="paramname">isSpr</td><td>Will contain true if eval pdo needs to limit pdo count to SPR otherwise false</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_PDSTACK_STAT_SUCCESS if operation is successful, CY_PDSTACK_STAT_BAD_PARAM if the parameters are invalid. </dd></dl>

</div>
</div>
<a id="gaae911bf71e2bf34e10ddead31588d74b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaae911bf71e2bf34e10ddead31588d74b">&#9670;&nbsp;</a></span>Cy_PdStack_Dpm_IsEprAvsModeActive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__pdstack__enums.html#ga2115782809414a20b28e6f5df83b7a7f">cy_en_pdstack_status_t</a> Cy_PdStack_Dpm_IsEprAvsModeActive </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcy__stc__pdstack__context__t.html">cy_stc_pdstack_context_t</a> *&#160;</td>
          <td class="paramname"><em>ptrPdStackContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>isActive</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to check whether EPR AVS mode is active. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptrPdStackContext</td><td>PdStack Library Context pointer.</td></tr>
    <tr><td class="paramname">isActive</td><td>State of EPR flag</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_PDSTACK_STAT_SUCCESS if operation is successful, CY_PDSTACK_STAT_BAD_PARAM if the parameters are invalid. </dd></dl>

</div>
</div>
<a id="ga1df6fdf79498cef6df1815bbdee6248b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1df6fdf79498cef6df1815bbdee6248b">&#9670;&nbsp;</a></span>Cy_PdStack_Dpm_ChangeEprAvsActiveFlag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__pdstack__enums.html#ga2115782809414a20b28e6f5df83b7a7f">cy_en_pdstack_status_t</a> Cy_PdStack_Dpm_ChangeEprAvsActiveFlag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcy__stc__pdstack__context__t.html">cy_stc_pdstack_context_t</a> *&#160;</td>
          <td class="paramname"><em>ptrPdStackContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to change state of EPR AVS mode active flag. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptrPdStackContext</td><td>PdStack Library Context pointer.</td></tr>
    <tr><td class="paramname">flag</td><td>sets/resets EPR AVS active flag.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>cy_en_pdstack_status_t </dd></dl>

</div>
</div>
<a id="gabe86f56a7117cd31bf55f25ebc706e1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabe86f56a7117cd31bf55f25ebc706e1c">&#9670;&nbsp;</a></span>Cy_PdStack_Dpm_IsValidAvsReq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__pdstack__enums.html#ga2115782809414a20b28e6f5df83b7a7f">cy_en_pdstack_status_t</a> Cy_PdStack_Dpm_IsValidAvsReq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcy__stc__pdstack__context__t.html">cy_stc_pdstack_context_t</a> *&#160;</td>
          <td class="paramname"><em>ptrPdStackContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>src_pdo_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cy_pd_pd_do_t&#160;</td>
          <td class="paramname"><em>rdo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to change state of EPR AVS mode active flag. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptrPdStackContext</td><td>PdStack Library Context pointer.</td></tr>
    <tr><td class="paramname">src_pdo_index</td><td>SRC PDO index.</td></tr>
    <tr><td class="paramname">rdo</td><td>Request Data Object received from port partner.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_PDSTACK_STAT_SUCCESS if operation is successful, CY_PDSTACK_STAT_BAD_PARAM if the parameters are invalid. </dd></dl>

</div>
</div>
<a id="gac66faebea2dbaf5915cf59d71bc94454"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac66faebea2dbaf5915cf59d71bc94454">&#9670;&nbsp;</a></span>Cy_PdStack_Dpm_EprSnkSendKeepAliveCb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_PdStack_Dpm_EprSnkSendKeepAliveCb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__pdstack__data__structures.html#ga87a37816b1bb27d6ab0f583a1ac01cdd">cy_timer_id_t</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptrContext</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function callback to initiate Keep Alive message. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Timer index</td></tr>
    <tr><td class="paramname">ptrContext</td><td>Callback context</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="gaff5593f490badca6dc53a2d5b9941ea7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaff5593f490badca6dc53a2d5b9941ea7">&#9670;&nbsp;</a></span>Cy_PdStack_Dpm_UpdateSnkMaxMin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__pdstack__enums.html#ga2115782809414a20b28e6f5df83b7a7f">cy_en_pdstack_status_t</a> Cy_PdStack_Dpm_UpdateSnkMaxMin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcy__stc__pdstack__context__t.html">cy_stc_pdstack_context_t</a> *&#160;</td>
          <td class="paramname"><em>ptrPdStackContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>max_min</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to update the sink max/min current/power at runtime thereby overriding the generated configuration by EZ-PD Configurator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptrPdStackContext</td><td>PdStack Library Context pointer.</td></tr>
    <tr><td class="paramname">count</td><td>Number of PDOs</td></tr>
    <tr><td class="paramname">max_min</td><td>Pointer to max/min current/power array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_PDSTACK_STAT_SUCCESS if operation is successful. CY_PDSTACK_STAT_BAD_PARAM if the parameters are invalid. </dd></dl>

</div>
</div>
<a id="gacfa6c9ebe83b586dc059244db086ed95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacfa6c9ebe83b586dc059244db086ed95">&#9670;&nbsp;</a></span>Cy_PdStack_Dpm_UpdateSnkCapMask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__pdstack__enums.html#ga2115782809414a20b28e6f5df83b7a7f">cy_en_pdstack_status_t</a> Cy_PdStack_Dpm_UpdateSnkCapMask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcy__stc__pdstack__context__t.html">cy_stc_pdstack_context_t</a> *&#160;</td>
          <td class="paramname"><em>ptrPdStackContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to update the sink PDO mask at runtime thereby overriding the generated configuration by EZ-PD Configurator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptrPdStackContext</td><td>PdStack Library Context pointer.</td></tr>
    <tr><td class="paramname">mask</td><td>PDO mask</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_PDSTACK_STAT_SUCCESS if operation is successful. CY_PDSTACK_STAT_BAD_PARAM if the parameters are invalid. </dd></dl>

</div>
</div>
<a id="gae2dd874498d2c7b9e16748935541442a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae2dd874498d2c7b9e16748935541442a">&#9670;&nbsp;</a></span>Cy_PdStack_Dpm_UpdateSnkCap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__pdstack__enums.html#ga2115782809414a20b28e6f5df83b7a7f">cy_en_pdstack_status_t</a> Cy_PdStack_Dpm_UpdateSnkCap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcy__stc__pdstack__context__t.html">cy_stc_pdstack_context_t</a> *&#160;</td>
          <td class="paramname"><em>ptrPdStackContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cy_pd_pd_do_t *&#160;</td>
          <td class="paramname"><em>pdo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to update the sink PDOs at runtime thereby overriding the generated configuration by EZ-PD Configurator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptrPdStackContext</td><td>PdStack Library Context pointer.</td></tr>
    <tr><td class="paramname">count</td><td>Number of PDOs</td></tr>
    <tr><td class="paramname">pdo</td><td>Pointer to the PDO array</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_PDSTACK_STAT_SUCCESS if operation is successful. CY_PDSTACK_STAT_BAD_PARAM if the parameters are invalid. </dd></dl>

</div>
</div>
<a id="ga29165181d3ace6983fe11f11decd9254"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga29165181d3ace6983fe11f11decd9254">&#9670;&nbsp;</a></span>Cy_PdStack_Dpm_UpdateSrcCapMask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__pdstack__enums.html#ga2115782809414a20b28e6f5df83b7a7f">cy_en_pdstack_status_t</a> Cy_PdStack_Dpm_UpdateSrcCapMask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcy__stc__pdstack__context__t.html">cy_stc_pdstack_context_t</a> *&#160;</td>
          <td class="paramname"><em>ptrPdStackContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to update the source PDO mask at runtime thereby overriding the generated configuration by EZ-PD Configurator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptrPdStackContext</td><td>PdStack Library Context pointer.</td></tr>
    <tr><td class="paramname">mask</td><td>PDO Mask</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_PDSTACK_STAT_SUCCESS if operation is successful, CY_PDSTACK_STAT_BAD_PARAM if the parameters are invalid. </dd></dl>

</div>
</div>
<a id="gaef57a1fc49e793766fd7f091dcdfddd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaef57a1fc49e793766fd7f091dcdfddd8">&#9670;&nbsp;</a></span>Cy_PdStack_Dpm_UpdateSrcCap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__pdstack__enums.html#ga2115782809414a20b28e6f5df83b7a7f">cy_en_pdstack_status_t</a> Cy_PdStack_Dpm_UpdateSrcCap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcy__stc__pdstack__context__t.html">cy_stc_pdstack_context_t</a> *&#160;</td>
          <td class="paramname"><em>ptrPdStackContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cy_pd_pd_do_t *&#160;</td>
          <td class="paramname"><em>pdo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to update the source PDOs at runtime thereby overriding the generated configuration by EZ-PD Configurator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptrPdStackContext</td><td>PdStack Library Context pointer.</td></tr>
    <tr><td class="paramname">count</td><td>Number of PDOs</td></tr>
    <tr><td class="paramname">pdo</td><td>Pointer to the PDO array</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_PDSTACK_STAT_SUCCESS if operation is successful, CY_PDSTACK_STAT_BAD_PARAM if the parameters are invalid. </dd></dl>

</div>
</div>
<a id="ga81d70dcf068687970e99777d6119955a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga81d70dcf068687970e99777d6119955a">&#9670;&nbsp;</a></span>Cy_PdStack_Dpm_UpdateEprSnkCap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__pdstack__enums.html#ga2115782809414a20b28e6f5df83b7a7f">cy_en_pdstack_status_t</a> Cy_PdStack_Dpm_UpdateEprSnkCap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcy__stc__pdstack__context__t.html">cy_stc_pdstack_context_t</a> *&#160;</td>
          <td class="paramname"><em>ptrPdStackContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cy_pd_pd_do_t *&#160;</td>
          <td class="paramname"><em>pdo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to update the EPR sink PDOs at runtime thereby overriding the generated configuration by EZ-PD Configurator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptrPdStackContext</td><td>PdStack Library Context pointer.</td></tr>
    <tr><td class="paramname">count</td><td>Number of PDOs</td></tr>
    <tr><td class="paramname">pdo</td><td>Pointer to the PDO array</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_PDSTACK_STAT_SUCCESS if operation is successful, CY_PDSTACK_STAT_BAD_PARAM if the parameters are invalid. </dd></dl>

</div>
</div>
<a id="ga96e4125b87b56935a6772547091d19b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga96e4125b87b56935a6772547091d19b3">&#9670;&nbsp;</a></span>Cy_PdStack_Dpm_UpdateEprSnkCapMask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__pdstack__enums.html#ga2115782809414a20b28e6f5df83b7a7f">cy_en_pdstack_status_t</a> Cy_PdStack_Dpm_UpdateEprSnkCapMask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcy__stc__pdstack__context__t.html">cy_stc_pdstack_context_t</a> *&#160;</td>
          <td class="paramname"><em>ptrPdStackContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to update the EPR sink PDO mask at runtime thereby overriding the generated configuration by EZ-PD Configurator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptrPdStackContext</td><td>PdStack Library Context pointer.</td></tr>
    <tr><td class="paramname">mask</td><td>PDO Mask</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_PDSTACK_STAT_SUCCESS if operation is successful, CY_PDSTACK_STAT_BAD_PARAM if the parameters are invalid. </dd></dl>

</div>
</div>
<a id="ga571254a255a639c850955f2ee44a4ff6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga571254a255a639c850955f2ee44a4ff6">&#9670;&nbsp;</a></span>cy_sw_timer_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cy_sw_timer_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcy__stc__sw__timer__t.html">cy_stc_sw_timer_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>sysClkFreq</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function initializes the software timer module. </p>
<p>This function initializes the data structures for timer management and enables the hardware timer used for the soft timer implementation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>The pointer to the context structure <a class="el" href="structcy__stc__sw__timer__t.html">cy_stc_sw_timer_t</a> allocated by the user. The structure is used during the SW Timer operation for internal configuration and data retention. The user must not modify anything in this structure.</td></tr>
    <tr><td class="paramname">sysClkFreq</td><td>SysClk frequency in MHz. This value is used to calibrate the watchdog timer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="ga4f7d0de989622862b23e48dd59ea4fcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4f7d0de989622862b23e48dd59ea4fcc">&#9670;&nbsp;</a></span>cy_sw_timer_start()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cy_sw_timer_start </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcy__stc__sw__timer__t.html">cy_stc_sw_timer_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>callbackContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__pdstack__data__structures.html#ga87a37816b1bb27d6ab0f583a1ac01cdd">cy_timer_id_t</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>period</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__pdstack__data__structures.html#ga677655f9c592cb223c59bf38678c1a1a">cy_cb_timer_t</a>&#160;</td>
          <td class="paramname"><em>cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start a specific soft timer. </p>
<p>All soft timers are one-shot timers which will run until the specified period has elapsed. The timer expiration callback will be called at the end of the period, if one is provided.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>The pointer to the context structure <a class="el" href="structcy__stc__sw__timer__t.html">cy_stc_sw_timer_t</a> allocated by the user. The structure is used during the SW Timer operation for internal configuration and data retention. The user must not modify anything in this structure.</td></tr>
    <tr><td class="paramname">callbackContext</td><td>Pointer to the caller context.</td></tr>
    <tr><td class="paramname">id</td><td>Unique timer id</td></tr>
    <tr><td class="paramname">period</td><td>Timer period in milliseconds.</td></tr>
    <tr><td class="paramname">cb</td><td>Timer expiration callback. Can be NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool True if the timer is started, false if timer start fails.</dd></dl>
<p>All soft timers are one-shot timers which will run until the specified period has elapsed. The timer expiration callback will be called at the end of the period, if one is provided.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>The pointer to the context structure <a class="el" href="structcy__stc__sw__timer__t.html">cy_stc_sw_timer_t</a> allocated by the user. The structure is used during the SW Timer operation for internal configuration and data retention. The user must not modify anything in this structure.</td></tr>
    <tr><td class="paramname">callbackContext</td><td>Pointer to the caller context</td></tr>
    <tr><td class="paramname">id</td><td>Unique timer id</td></tr>
    <tr><td class="paramname">period</td><td>Timer period in milliseconds. </td></tr>
    <tr><td class="paramname">cb</td><td>Timer expiration callback. Can be NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool True if the timer is started, false if timer start fails. </dd></dl>

</div>
</div>
<a id="ga1fa158c30f555b378dc841b4964a34bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1fa158c30f555b378dc841b4964a34bd">&#9670;&nbsp;</a></span>cy_sw_timer_start_wocb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cy_sw_timer_start_wocb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcy__stc__sw__timer__t.html">cy_stc_sw_timer_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__pdstack__data__structures.html#ga87a37816b1bb27d6ab0f583a1ac01cdd">cy_timer_id_t</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>period</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start a specific soft timer without providing a callback for expiry notification. </p>
<p>The status of the timer (running or not) can be checked using the <a class="el" href="group__group__pdstack__functions.html#ga6de412b66324addf487bed9fda267f3e">cy_sw_timer_is_running</a> API.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>The pointer to the context structure <a class="el" href="structcy__stc__sw__timer__t.html">cy_stc_sw_timer_t</a> allocated by the user. The structure is used during the SW Timer operation for internal configuration and data retention. The user must not modify anything in this structure.</td></tr>
    <tr><td class="paramname">id</td><td>Unique timer id</td></tr>
    <tr><td class="paramname">period</td><td>Timer period in milliseconds.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool True if the timer is started, false if timer start fails.</dd></dl>
<p>Start a specific soft timer without providing a callback for expiry notification.</p>
<p>All soft timers are one-shot timers which will run until the specified period has elapsed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>The pointer to the context structure <a class="el" href="structcy__stc__sw__timer__t.html">cy_stc_sw_timer_t</a> allocated by the user. The structure is used during the SW Timer operation for internal configuration and data retention. The user must not modify anything in this structure.</td></tr>
    <tr><td class="paramname">id</td><td>Unique timer id</td></tr>
    <tr><td class="paramname">period</td><td>Timer period in milliseconds.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool True if the timer is started, false if timer start fails. </dd></dl>

</div>
</div>
<a id="ga3006fefdec6f3e5cc0ba40533ebd90e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3006fefdec6f3e5cc0ba40533ebd90e1">&#9670;&nbsp;</a></span>cy_sw_timer_stop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cy_sw_timer_stop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcy__stc__sw__timer__t.html">cy_stc_sw_timer_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__pdstack__data__structures.html#ga87a37816b1bb27d6ab0f583a1ac01cdd">cy_timer_id_t</a>&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stop a soft timer which is currently running. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>The pointer to the context structure <a class="el" href="structcy__stc__sw__timer__t.html">cy_stc_sw_timer_t</a> allocated by the user. The structure is used during the SW Timer operation for internal configuration and data retention. The user must not modify anything in this structure.</td></tr>
    <tr><td class="paramname">id</td><td>Unique timer id</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="ga6de412b66324addf487bed9fda267f3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6de412b66324addf487bed9fda267f3e">&#9670;&nbsp;</a></span>cy_sw_timer_is_running()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cy_sw_timer_is_running </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcy__stc__sw__timer__t.html">cy_stc_sw_timer_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__pdstack__data__structures.html#ga87a37816b1bb27d6ab0f583a1ac01cdd">cy_timer_id_t</a>&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether the specified soft timer is currently running. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>The pointer to the context structure <a class="el" href="structcy__stc__sw__timer__t.html">cy_stc_sw_timer_t</a> allocated by the user. The structure is used during the SW Timer operation for internal configuration and data retention. The user must not modify anything in this structure.</td></tr>
    <tr><td class="paramname">id</td><td>Unique timer id</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool True if the timer is running, false otherwise. </dd></dl>

</div>
</div>
<a id="ga729796ffbdea922f8e5a7fd5f321cd0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga729796ffbdea922f8e5a7fd5f321cd0d">&#9670;&nbsp;</a></span>cy_sw_timer_range_enabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cy_sw_timer_range_enabled </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcy__stc__sw__timer__t.html">cy_stc_sw_timer_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__pdstack__data__structures.html#ga87a37816b1bb27d6ab0f583a1ac01cdd">cy_timer_id_t</a>&#160;</td>
          <td class="paramname"><em>low</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__pdstack__data__structures.html#ga87a37816b1bb27d6ab0f583a1ac01cdd">cy_timer_id_t</a>&#160;</td>
          <td class="paramname"><em>high</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether the any of the soft timers in the specified range are currently running. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>The pointer to the context structure <a class="el" href="structcy__stc__sw__timer__t.html">cy_stc_sw_timer_t</a> allocated by the user. The structure is used during the SW Timer operation for internal configuration and data retention. The user must not modify anything in this structure.</td></tr>
    <tr><td class="paramname">low</td><td>Lowest soft timer ID to be checked.</td></tr>
    <tr><td class="paramname">high</td><td>Highest soft timer ID to be checked.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool True if the timers are running, false otherwise.</dd></dl>
<p>Check whether the any of the soft timers in the specified range are currently running.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>The pointer to the context structure <a class="el" href="structcy__stc__sw__timer__t.html">cy_stc_sw_timer_t</a> allocated by the user. The structure is used during the SW Timer operation for internal configuration and data retention. The user must not modify anything in this structure.</td></tr>
    <tr><td class="paramname">low</td><td>Lowest soft timer ID to be checked.</td></tr>
    <tr><td class="paramname">high</td><td>Highest soft timer ID to be checked.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool True if the timers are running, false otherwise. </dd></dl>

</div>
</div>
<a id="ga61adc4b2eb587c1a2ae7b2e87dfa3072"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga61adc4b2eb587c1a2ae7b2e87dfa3072">&#9670;&nbsp;</a></span>cy_sw_timer_get_count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t cy_sw_timer_get_count </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcy__stc__sw__timer__t.html">cy_stc_sw_timer_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__pdstack__data__structures.html#ga87a37816b1bb27d6ab0f583a1ac01cdd">cy_timer_id_t</a>&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the time (in ms) remaining for timer expiration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>The pointer to the context structure <a class="el" href="structcy__stc__sw__timer__t.html">cy_stc_sw_timer_t</a> allocated by the user. The structure is used during the SW Timer operation for internal configuration and data retention. The user must not modify anything in this structure.</td></tr>
    <tr><td class="paramname">id</td><td>Unique timer id</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Time remaining for expiration of the soft timer.</dd></dl>
<p>Returns the time (in ms) remaining for timer expiration.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>The pointer to the context structure <a class="el" href="structcy__stc__sw__timer__t.html">cy_stc_sw_timer_t</a> allocated by the user. The structure is used during the SW Timer operation for internal configuration and data retention. The user must not modify anything in this structure.</td></tr>
    <tr><td class="paramname">id</td><td>Unique timer id</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Time remaining for expiration of the soft timer. </dd></dl>

</div>
</div>
<a id="ga4d12d06f621bb1dd95fcbd011516682f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4d12d06f621bb1dd95fcbd011516682f">&#9670;&nbsp;</a></span>cy_sw_timer_stop_all()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cy_sw_timer_stop_all </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcy__stc__sw__timer__t.html">cy_stc_sw_timer_t</a> *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stops all active soft timers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>The pointer to the context structure <a class="el" href="structcy__stc__sw__timer__t.html">cy_stc_sw_timer_t</a> allocated by the user. The structure is used during the SW Timer operation for internal configuration and data retention. The user must not modify anything in this structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<p>Stops all active soft timers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>The pointer to the context structure <a class="el" href="structcy__stc__sw__timer__t.html">cy_stc_sw_timer_t</a> allocated by the user. The structure is used during the SW Timer operation for internal configuration and data retention. The user must not modify anything in this structure..</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="gaa9ff160349cf0db1ab09fc42eeafe57b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa9ff160349cf0db1ab09fc42eeafe57b">&#9670;&nbsp;</a></span>cy_sw_timer_stop_range()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cy_sw_timer_stop_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcy__stc__sw__timer__t.html">cy_stc_sw_timer_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__pdstack__data__structures.html#ga87a37816b1bb27d6ab0f583a1ac01cdd">cy_timer_id_t</a>&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__pdstack__data__structures.html#ga87a37816b1bb27d6ab0f583a1ac01cdd">cy_timer_id_t</a>&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function stops all soft timers with ids in the specified range. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>The pointer to the context structure <a class="el" href="structcy__stc__sw__timer__t.html">cy_stc_sw_timer_t</a> allocated by the user. The structure is used during the SW Timer operation for internal configuration and data retention. The user must not modify anything in this structure.</td></tr>
    <tr><td class="paramname">start</td><td>Starting timer ID. The value is inclusive.</td></tr>
    <tr><td class="paramname">end</td><td>Ending timer ID. The value is inclusive.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="gaece137e47862aa5d0b40edf013a71738"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaece137e47862aa5d0b40edf013a71738">&#9670;&nbsp;</a></span>cy_sw_timer_num_active()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t cy_sw_timer_num_active </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcy__stc__sw__timer__t.html">cy_stc_sw_timer_t</a> *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns number of active timers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>The pointer to the context structure <a class="el" href="structcy__stc__sw__timer__t.html">cy_stc_sw_timer_t</a> allocated by the user. The structure is used during the SW Timer operation for internal configuration and data retention. The user must not modify anything in this structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of Active Timers </dd></dl>

</div>
</div>
<a id="ga28d1dbbc963e015cd3689f8a4263e425"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga28d1dbbc963e015cd3689f8a4263e425">&#9670;&nbsp;</a></span>cy_sw_timer_enter_sleep()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cy_sw_timer_enter_sleep </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcy__stc__sw__timer__t.html">cy_stc_sw_timer_t</a> *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function prepares the timer module and the hardware timer for entering device deep sleep. </p>
<p>This must be called prior to entering deep sleep mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>The pointer to the context structure <a class="el" href="structcy__stc__sw__timer__t.html">cy_stc_sw_timer_t</a> allocated by the user. The structure is used during the SW Timer operation for internal configuration and data retention. The user must not modify anything in this structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="ga548d2c906554c3e70bf1e25a7feeb111"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga548d2c906554c3e70bf1e25a7feeb111">&#9670;&nbsp;</a></span>cy_sw_timer_interrupt_handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cy_sw_timer_interrupt_handler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcy__stc__sw__timer__t.html">cy_stc_sw_timer_t</a> *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function implements the interrupt handler callback used by the Soft Timer module, and is expected to be called by the application whenever the appropriate SysTick or WDT interrupt is received. </p>
<p>This function scans all running timer instances and decrements their count as appropriate. If any of the timers has expired, it is stopped, de-allocated and the corresponding callback called (if not NULL). The timer can be restarted from the callback function if so desired.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>The pointer to the context structure <a class="el" href="structcy__stc__sw__timer__t.html">cy_stc_sw_timer_t</a> allocated by the user. The structure is used during the SW Timer operation for internal configuration and data retention. The user must not modify anything in this structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<p>This function implements the interrupt handler callback used by the Soft Timer module, and is expected to be called by the application whenever the appropriate SysTick or WDT interrupt is received.</p>
<p>The ISR scans all running instances and decrements the count appropriately.</p>
<p>Timer ISR is called every 1ms (if not using Tickless implementation) or configured period if using tickless implementation. If there is any soft timer ON, in the ISR all active timer instances are decremented and then checked for timeouts. In case of timeout the timer is stopped and de-allocated. In case, a timer needs to be re-started, it can be done from the callback. On timer expire events are also raised here for various modules.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>The pointer to the context structure <a class="el" href="structcy__stc__sw__timer__t.html">cy_stc_sw_timer_t</a> allocated by the user. The structure is used during the SW Timer operation for internal configuration and data retention. The user must not modify anything in this structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="ga5caa507456d28bdc2941796cead1bbe9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5caa507456d28bdc2941796cead1bbe9">&#9670;&nbsp;</a></span>cy_sw_timer_get_multiplier()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t cy_sw_timer_get_multiplier </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcy__stc__sw__timer__t.html">cy_stc_sw_timer_t</a> *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function retrieves the number of low frequency (LF) clock ticks required per ms. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>The pointer to the context structure <a class="el" href="structcy__stc__sw__timer__t.html">cy_stc_sw_timer_t</a> allocated by the user. The structure is used during the SW Timer operation for internal configuration and data retention. The user must not modify anything in this structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of LF clock ticks per ms.</dd></dl>
<p>This function retrieves the number of low frequency (LF) clock ticks required per ms.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>The pointer to the context structure <a class="el" href="structcy__stc__sw__timer__t.html">cy_stc_sw_timer_t</a> allocated by the user. The structure is used during the SW Timer operation for internal configuration and data retention. The user must not modify anything in this structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of LF clock ticks per ms. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part
<div id="nav-path" class="navpath">
    <ul>
        <li class="footer">
            Generated for <b>PDStack Middleware Library 1.20</b> by <b>Cypress Semiconductor Corporation</b>.
            All rights reserved.
        </li>
    </ul>
</div>
-->
</body>
</html>
